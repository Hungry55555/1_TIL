각 숫자가 몇개 있는지 알고 싶다면...?
0~9사이 정수로만 주어진다.
카운트배열??
아직 잘 모르겠는뎅....
제한 사항이있어서 버블정렬도 쓴다
정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능: 각항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트 들의 배열을 사용하기 때문이다.

카운트들을 위한 충분한 공간을 할당하려면 집합내의 가장 큰 정수를 알아야 한다.

1단계:
Data에서 각 항목들의 발생 회수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열을  counts에 저장한다.

0~4까지 정수로 구성되어있으면
0 1 2 3 4

count = [0]*l
for x in Data:

k가 4고 5개가 있어야 하니까
N개 : [0]*k
마지막자리 N : [0]*(N+1)
counts = [0] * (k+1)

++ 이건 슈도 코드 표현시 하나 증가시킨다는 의미

오오

약간 딕셔너리에서 정렬하는 느낌
0,1,2,3,4라는 인덱스를 써서
가장 마지막 k라는 숫자까지
0으로 채워진 배열을 만들거야!!라고 하면?
count = [0]*(k+1)
로 되어있으니까 마지막 숫자 +1 해야함

1단계
이 크기를 정하는? 더 크게 만드는건 ok!
넉넉쓰...
0~9까지 
그냥 리스트에 순서가 있다는 점을 이용해서 본인의 index를 숫자로 생각하고 위치에 +1을 해주며 세는것

걍 앞에꺼까지 더하면 되는게 아닌강...

k가 마지막 수라고 했으니까?
0까지는 맨 앞이니까 그냥 그대로!
1~마지막 원소까지?

for i: l->k
counts[i]<-counts[i-1]+counts[i]

그냥 더하면 되는 부분

구간을 알려줄테니 그 사이 합을 계산해 보거라...
구간 더해봐
겹치는데?!
일부 겹치는데!?

사잇값은 전체 합 값에 시작 전 부분과 시작 끝 부분의 원래 값을 빼준값


정렬...
원본데이타랑 같은 크기의 Temp 만들기 이 템프는 정렬된 결과를 저장할 배열을 하나 만든다
원본에서의 맨 마지막 숫자부터 확인해봄
???
또 이해 안된다
4는 가서 확인해보니
4까지ㅡㄴ 총 8개의 숫자가 있으니 8번째는 6겠구만!
1개는처리되어서 한개는 빼줘야 하기 때문

1개는 자리를 잡았기때문에 남은애들 기준으로 자릴르 잡을때 인덱스 2는 1이겠구만!

원본을 기준으로 맨 끝에 있던 일이
* 같은 숫자가 나타나면 원본의 순서를 유지한채로 정렬한다.

그럼 템프에는 정렬된 순서대로 정렬이 된다
오른쪽 끝부터 쭉 흝으면서 정렬된 자리를 찾아가는 방식
이것이 카운팅 정렬

????????????
뭔소리래
브레이크 포인트 그 빨간색 점 같은게 브레이크  포인트임
---
쉬는시간
---

이해가 안된다면... 어쩔테지?
이해가 안되는데?


baby gin이라는 게임이 있음
뭔디...?


완전검색
* 모든 경우의 수를 나열해 보고 확인하는 기법
* Brute-force 혹은 generate-and-test 기법이라고도 불리운다.
* 모든 경우의 수를 테스트한 후, 최종 해법을 도출한다.
* 일반적으로 경우의 수가 상대적으로 작을 때 유용하다.
* 모든 경우의 수를 생성하고 테스트 하기 때문에 수행속도는 느리지만, 해답을 찾아내지 못할 확룔이 작다.
* 주어진 문제를 풀때, 우선 완전 검색으로 접근하여 해답을 도출한 후 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직하다.

A형의 목표: 완전검색으로 문제를 해결할수있어???
정확하게 완전검색으로 풀어도 대부분은 풀린다!
완전 검색할때 쓸데없는 중복은 다름
다 나열하면 6! 만큼 생김

모든 경우를 테스트하면 효율을 고려할 필요는 없고 현재 우리가 배운걸로는 불가능하다

순열
nPr: n개 중 r 개를  택하는 순열 표기
뭔소리야???

탐욕 기법
탐욕?
최적화라기에는 좀 그렇고 좀 단순하게 생각해보는 근시안적인 방법

그 순간에 떠오르는 방식을 그냥 선택해서 진행해 나가 최종적인 해답에 도달하는 것
