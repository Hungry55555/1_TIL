계산기 스택
후위 표기 법을 이용한 계산기 만드는 문제
보통 중위표기법을 사용하지만 후위 표기법으로 커ㅁ퓨터에서도 이런 표기법을 사용해서 계싼을 할 수 있따
스택을 이용해서 계산 한다
스택 활용법
스택의 특징을 어떻게 후위 표기법에 적용했는지
어떻게 이요하는지를 잘 봐야함
스택에 집중
스택이라는 자료구조의 특징을 잘 기억해주기

괄호 전부 제거 그럼 후위 표기법으로 변경이 되어짐
사람이 하기 쉽게 하기 위한 변경방법
컴퓨터로 변경하는 방법
스택ㅇ ㅣ용해서는 어케 바꾸는지?
입력 받은 중위 표기식에서 토큰을 읽는다
토큰은 하나의 문자
이 문자가 피연산자(숫자)면 해당 문자는 출력

얘가 숫자면 바로 출력!!!!!!!
스택의 가장 위에 있는 막들어간 연산자 보다 우선 순위가 높으면 스택에 푸쉬
연산자에 대한 우선순위가 존재
연산자에 대한 우선순위를 기준으로 스택에 가장 위에있는것보다 우선순위가 높다면 여기 넣어주면 됨
우선순위가 1이라면 들어가는게 2
그대로 스택에 쌓으면 된다.
이렇게 들어가게 되면됨
근데 만약 작다면?
그렇지 않다면????
여기 들어가있는게 나보다 더 큰게 위에 있다면!!
top에 있는 연산자를 문자의 우선순위보다 작을때까지 pop
만만한 숫자 만날때까지 스택에 있는것을 전부 pop해서 문자 push
연산자 우선수위를 따졌을때top에 있는게 문자보다 작다면 그냥 push  top에 있는게 문자보다 크다면 작은 top을 볼때까지 pop을 하고 작은 top이 나타났다면?!
push!
dustk문자> top 
문자<top 나올때까지 pop

괄호 있따면 열리는 괄호가 나올때까지 pop연산 수행
pop한 연산자를 계속 출력
왼쪽 괄호가 나올 때 까지
열리는 괄호가5개의 문자들이 스택으로 들어갈 수 가 있고, 들어가는 순서는 연산자 우선순위를 따져서 넣어주면 됨
열리는 괄호 여는 괄호는 닫는 괄호일때만 pop이 되덜하...
왼쪽 괄호까지 pop되면 출력하지 않는다.

연산자만 출력하고 괄호는 따로 출력하지 않음
여는 괄호는 따로 출력하지 않음
중위표기식에서 더 읽을 것이 없다면 중지하고 더 읽을 것이 있따면 1부터 다시 반복

스택에 연사낮가 남아있다면 모두 pop하여 출력
스택 밖 왼쪽 괄호는 우선 순위가 가장 높지만 스택 안 왼쪽 괄호는 우선순위가 가장 낮다

다시 한번 정리
중위표기식에서 하나씩 문자를 받음
숫자라면 일단 출력
숫자가 아니라면?
연산자가 됨
숫자일때와 숫자가 아닐때 두가지로 먼저 나눠야함
숫자가 아닐때 스택에 넣는데 스택에 넣게 되는데 스택에 넣는 공식은 다음과 같음
문자 우선순위가 top 보다 높아면 push
문자 우선순위가 top 보다 낮다면 작은 top을 볼때까지 pop()

문자가 탑보다 작을때까지
크거나 같다면 pop!
스택에 넣는 조건이 요렇게 2가지로 나뉘어 지고 탑보다 문자가 더 우선순위가 높다면
그냥 push 문자가 탑보다 작거나 같다면 탑이 나보다 낮은 녀석을 볼때까지 스택에서 전부 빼줌
pop해서 제거하기
그래서 스택에 넣는 조건이 다음과 같음
괄호 조건
괄호에 대한 조건은 닫는 괄호가 나오면 여는 괄호가 나올때까지 pop해주기
숫자가 아닐때 ????
여는 괄호가 나올때까지 스택에서 계쏙 뺌
왼쪽 괄호를 만날때까지 스택에서 빼줌
닫는 괄호일때
닫는 괄호일때는 왽쪽괄호를 만날때까지 
뺀 연산자를 전부 출력 괄호 빼고
+-x%
언제까지 반복??
중위표기식에서 더이상 읽을 것이 없을때까지
스택에 남아있는게 있따면 전부 pop해서 스택 비우기 전부다 pop해주면 된다.
괄호는 조건부로 가장 쏄때도 있고 약할때도..
스택의 밖에있을때 가장 높고 안에있을때 가장 낮음

10p isp icp가 우선순위라고 보면됨
숫자가 크면 우선순위가 높다.
스택에 안에 있을때와 스택밖에 있을때
여는 괄호는 스택밖에있을때 우선순위 가장 높음
안으로 들어온 순간 우선순위 가장 낮아짐
요 규칙대로 작성해주면 됨
여는 괄호가 있다면 우선순위가 가장 높기 때문에 읽어오는게 여는괄호다?무조건 push~
+는 우선순위가 1 괄호보다 0보다 1이 더 크기때문에 숫자는 출력 곱하기는 더하기 보다 높다
얘는 2고 플러스는 1
여는 괄호 스택밖은 3, 스택안으로 들어오면 쭈그리

가장 위에있느 top은 빼기?
pop 닫ㄴ는가ㅗㄹ호?
여 걸 곱하기로 바꾸기 나누기?
우선순위가 갔다 낮지 않았다 그래서 pop으

후위표기법으로 나타낸 것을 계싼하는 방법
숫자와 마찬가지로 연산자와 숫자를 나눠ㅜㅈ면 됨
스택에 푸쉬함 숫자를 만난다면
계산을 할 때는 숫자를 스택에 넣어주면 됨
앞에거 빼기 뒤에꺼
앞에거 곱하기 뒤에ㅓㄱ
앞에꺼 나누기 뒤에꺼ㅓㅓㅓㅓ계ㅏㅅㄴ
요 순서로 계싼 햊ㅁㄴ 됨 요 걸 계쏙 반복
쉿ㄱ 전부 종료되면 스택에는 하나만 남아있음
그걸 pop해서 출ㄹ력
나온결과 다시 push
순서 주의
곱하기 나왔으니 두개 마찬가지로 꺼내서 나온 결과를 다시 스택에 넣어주고
숫자가 나오면 스택에 ㅈ무적ㄴ 투입모두이ㅡ 연산이 끝났을때는 스택에 연산이 하나만 남게 되겠고 이 하나를 출력해주면 최종 출력값이 나옴
정말 스택을 차부

조건만 잘 정리하기

백트래킨


DFS와 몹시 헷갈림
왜냐면 얘도 다시 돌아가서 재귀나 이런 코드들이 많음
이 두개의 공-ㅜ
특정 문제에 대해서 어떠한 값ㅇ르 ㅁ=뻐아
백트래킹은 유망한 것 조건 정답이 되는 경우
정답이 될 수 없는 경우는 ㅇㅁㄱ
모든 경우의 수를 보는 거
정답이 아니라 접답이 될 수 있는 경우의 수를 측정하는ㄴ것
여기로 다시 되돌아가게 되는데
요 되돌아 가기 ㄷ위해서 재귀나 stack을 사용함
DFS도 다음 경로를 확인하기 위해서 되돌아 가는 연산이 주어짐 두개의 목적 자체가 얘는 정답을 착=ㅈ기 위해서 사용하ㅡㄴㄴ게 빽트래킹이ㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏ
DFS는 모든 노드를 망문하기 위해서 DFS를 씀
되돌아가는 특징이 있기때문에 재귀ㅡㄹ 사용함
우
백트래킹과 DFS 의 코드 자체는 굉장히 유사함
하지만 DFS는 모든 노드를 방문하는게 목적이기 때무에 백트래티아ㅗ는 목족ㄷ르의 점수ㅏ
더이상탐색을 ㅏ지 않는다는 가지치기 존재해서 DFS 종류와 
DFS와 굉장히 유사한 측볌ㄴ이 있음 퀴능ㄹ 어ㅣㄷ 다 주면 ㅈㅎ을까 백트캐이 무
엔 퀸이라는 문제 스웨아에는 없는듯??
암튼 함 풀어보기 백트래킹과 깊이우선탐색의 차이는 가지치기
깊이우선 탐색은 모든 노드를 방무하늑
불필요한 계획은 아예 실행도 안함
근ㄷ ㅔ모든나그래서 큰 차이가 없을 수도 있음
이런 특징 잘 기억해 두기
백트레킹은 가지치기해서 모든 번호를 검사하지는 않
시작에서 처음선택할 수 있는 경우의 수는 총 3가지 A 선택후에도 3가지 b도 3가지 
B도 ㅠ
DFS 같은 경우는 모든 것을 전부 선택
모든 경우를 다 탐색하는디
백은 A부터 살펴봄
첫 카드를 A를 선택하면 자ㅓㅇ답 가능?
이거를ㄹ 유망한가로 표현할 수 있음 즉 A를 통한 선택은 어떠하 ㄴ 거승ㄹ 선
바로 첫카드를 b 를 고르게 됨
여기 이 가지는 유망해
짱 유망해
너는 정답이 될 가능성이 있어 그 다음 노드를 보는데 A가 오면띠를 봤떠니 굉장히 유망함
A를 이렇게 표기했다는 것은 이만큼의 후보를 검사할 필요가 없어졌다는 것 이건 A를 건너냄으로써사ㅕ제 ㅏ일이었네
아예 요거를 가지치기라고 함
백트래킹의 특징 가지치기가 있따 DFS 를 실시하는데 유망한지를 점검하는 부분을 추가
유망하지 않다면 부모 노드로 돌아가는 부분이 ㅚㅣㅣㅣㅣㅣㅣㅣㄷㄷㄷㄷㄷㄷㄷㄷㄷㄷㄷㄷㄷㄷㄷㄷㄷㄷㄷㄷㄷㄷㄷㄷㄷㄷㄷㄷㄷㄷㄷㄷㄷ디ㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣㅣ
각 그걸 그렸을때 트리가 나옴좌표값이 될 것
공간이 없어서 그렇지 1,3 1,4에 대한 트리도 있을 것
들어서 푸는 문제는 거의 백 트래킹으로 풀어보기
상태 공간 문제는 백 트래킹으로 푼다고 보면 됨
그래서 훨씬 찾는 노드가 줄어들더라
그다음 부분집합은 배트래킹 기법으로도 만들 수 있고 반복문 안쓴다 비트연산을 이용하거나 백 트래킹을 이용해서도 만들 수 있음 1,23,
이용해서 부분집합 이용할때 요거 요거 ㅈ나는 
사실 전부니까
상태공간 트리 
ㅏ가지치기 가 업승면 DFS
합이 20이하가 되는 경우의 수가 총 몇가지?
21부터 뽑힌다명여기 가지치기 조건이 되는것
연ㅅ브문제 2ㅓㅂㅂ능ㄴ 넣어두지는 않았는데 넣어줌
밑에 순열은
내일 한 번더 할거라고 봄
내일 한 번 더 할 거라고 본다
관련코드도 내일 문의

