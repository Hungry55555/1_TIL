이름 검색 규칙

이름 식별자 = 변수
가장 좁은 범위 부터 넓은 범위로 감

가장 먼저 로컬에서 해당 변수가 있나 찾아보고 인클로즈드는 일단 없다고...
그다음 글로벌에서 찾음
그다음이 빌트인 스코프를 찾아봄

그리고 함수 내에서는 바깥에 있는 변수에 접근이 가능함
리드 온리는 가능하지만 수정은 할 수 없음
수정하려면 로컬에서 글로벌 수정하려면 글로벌이라는 키워드를 붙여주며 선언해줘야함

값이 저장된 메모리에 가서 값을 읽어올수있음

함수 내부에서 넘 자체가 global이다라고 알려줘야함

하지만 num_list = [1,2,3,4] 이건

로컬에 가져와 써도 에러가 생기지 않음

이건 데이터 타입 특징대문

리스트 같은 경우에는 리스트 값이 들어간게 아니라 리스트 자체가 값의 모임
값의 모임은 값이늘어났따 줄어들었다 하기 때문에 넘 리스트는 해당 리스트의 시작 주소를 가르킴

넘 리스트를 하면 에러
하지만 넘 리스트 내부에 있는 걸 바꾸면 가능~
리스트의 시작 주소 위치는 바뀌지 않고 내부 값이 바뀌는건 넘리스트와는 관계없어서 그냥 그렇게 되었다

넘 리스트 얼레벌레 컬렉션 타입들은 따로 글로벌을 사용하지 않아도 되더라

LEGB 좀 망각했을때 집에가서 아까 500 어쩌구 해보도록

값을 단지 참고할때는 굳이 글로벌 안써도 괜찮지만 굳이 내부에서 수정하려면 글로벌을 사용해야함

이건 그냥 한 번 읽어보시길..
신택스 에러가 발생

글로벌 키워드는 진짜 쓰지 마라 여기서나 쓰는거지 진짜 고용ㄷ사용되고 변하지 않는 상수값이나 써라
글로벌값을 수정하고 싶으면 함수 인자로 받아 처리하고 그 반환값을 처리한다

## 재귀 함수


실행을 바로하는게 아니라 현재 준비된 상태
값이 필요하다고 하면 준비된 코드가 하나씩 값을 넣어서 그 결과를 돌려줌

모든지 실행된게 아니라실행 준비된 상태로 값이 필요할때 실행이 된다.

for i in map
list로 형 변환을 하게 되면 모든 값을 필요로 하기 때문에 형변환이 되면서 값이 튀어나오게 된다.

오브젝트 어쩌구가 나온다 준비된 상태다
내가 달라고 할때마다 값을 하나씩 주겠구만!
zip은 iterable
그렇게 들어오면?
같은 인덱스 끼리 튜플로 묶어줌
집도 보면 오브젝트임

살려줘!!!!!!!

람다함수는 나중에 자바할때쯤이면 람다를 마스터한다
ㅎ...
사람살려...

함수명이 없어서 익명함수라고 부름

람다 키워드 호출하고 매개변수: 표현식은 리턴되는 값
반환되는 값을 표현식으로 작성해라!

리턴 생략

패킹 여러 값을 변수 하나로 묶어담는것을 패ㅏ킹 이라고함

패킹은 여러개를 튜플 형태로 묶음

ㅎㅎㅎㅎㅎㅎㅎㅎㅎ
변수 값 할당할때 *를 찍으면 포장 패킹이다

함수를 정의할때 가변인자 리스트 이건 함수정의할때니까 매개 변수
변수 앞에 붙여주면 값을 할당하기 위한 변수에다가 별을 붙여주면 패킹이됨

가변인자리스트도 따지고 보면 패킹임

매개변수에 별을 붙이는 것

풀어 버리는것
언팩킹

일단
요고는 기본적ㅇ으로 변수를 얘는 패킹

언패킹
요 값을 요렇게 사용할 수 있음

근데 이렇게 쓰기 보다는
함수를 호출할대 인자앞에 *이 붙으면 
인자는 전달되는 값
전달되는 값앞에 *이 붙으면 이거는 언팩킹이 된다.

앞에 있는 요 대괄호가 없어지는 효과가~

패킹은 함수를 정의할때 매개 변수앞에 *이 붙은것

비닐 포장 준비

함수를 호출할때 전달되는 값 앞에 *을 붙이면 비닐포장을 벗기는 것

키 값이랑 매개변수랑 일치해야지만 사용이 가능함
키워드 인자 형태로 비닐이 풀림
키워드 인자라 함은 key=value 형태로 전달이 되어 지는데 요 값이 존재해야 한다.
그러면 쏙 들어감

하다보면 익숙해질듯 지금은 답 이 약간 안보임

정리하자면 패킹 연산자로 사용할때는 하나의 튜플로 묶고 언패킹 연산자로 사용할때는 함수의 인자로 전달할때

** 언패킹연사자로 사용할때는 키값ㅆ아을 키워드 인자로
언패킹하여 함수의 인자로 전달하는 역할

인자(전달되는 값)
앞에 *이나 ** 언패킹


---

어제꺼
시퀀스는 수넛대로 나열해서 정리하는 타입
시퀀스 특징 기억하기

리스트 넘어감~
알고리즘에서 리스트 모르면 큰일나니까 기본으로 이해하고
튜플은 리스트와 같은데 변경이 불가능하다는 차이가 있음

튜플에서 주의할때 정의할때 반드시 뒤에 ,를 적어줘야 튜플로 인식하게된다

튜플은 리스트와 거의 비슷함

레인지는 특정 연속된 정수 시퀀스를 생성하는 변경 불가능한 자료형

레인지 앞에 들어가는건 이상 미만
하나 있을때는 0부터 시작

넌 시퀀스 타입으로는 딕셔너리와 셋이 있음
단어가 키
뜻이 밸류라고 불린다라고 생각하면 키밸류 쌍에 대한 이해는 끝났다
사전 단어와 뜻 쌍 같이
딕셔너리
표현은 중괄호
ㅆㅇ을 그대로 안에다가 넣어주면 됨~
키를 입력을 해주면 값에 접근 가능
set 중복이 없는 변경 가능 자료형 
리스트에서 중복 제거위해 셋으로 형변환 했다가 리스트로 형변환 시킴
그러면 중복제거가 간ㅇ함

셋같은 경우는 순서가 없음
셋은 순서가 없어 셋은 저ㅓㅂ근때 훨씬 빠ㅡ게 다닐수 있는데 셋 연산자를 할대 리스트 보다 인을 사용할때 속도가 좀 더 빨림
인 연산잘르 쓸때는 셋으로 형변환 해서 사용해도 무방함

집합 연산자로 많이 사용하는 합집합 차집합 교집합 셋 타입으로 전부다 계산이 된다.
다른 타입

넌

값이 없음을 표현하는 자료형

불린 참 거짓 나타내는 자료형

컬렉션 여러개의 항목을 담는 자료 구조

그래서 컬렉션 정리하면 다음고 ㅏ같음

스트링 튜플 변경 불가하고 순서는 스트링 리스트 채플은 존재한다

저 테이블 잘 정리해 두게나

파이썬 튜터로도 한 번 눈으로 식ㄱ화해서 두어라!!
암시장의 형 변화는
숫자형에서 서로 데이터 타입을 암시적으로 형변환이 일어나고 데이터손실을 최소화 할려고
손실!
그러면 안된까 조금도 많은것을 표혀핳ㄹ수있는 플롯으로 형변환이 된다'
트루 폴스 뿐
좀더 많은 것을 표현 할 수 있음
트루가 1호 불리언이 인트의 ㅓ브클래스
암시적 형변환
 uf 듀ㅏ애 ㅈㅎ곤'
 이 조건을 판별할ㄸ이 조건이 숫자로 무시함 이때 참읹 ㅓ지신지 확인을 해야함
 비어있는 딕셔너리 요런 값들은 전부다 펄스를 의미하고 값이 존재하기만 하면 전부다 트루가 된다
 그럼 if 'false:
 문자열이 존재하기 때문에 true로써 판단이 됨
 이때 암시적으로 변환을 해서 판단을 한다
 숫자 3.5를 인티저로 한방에 변화가 안된다
 컬렉션 간의 형 변환 정리
ㅂ     변환하려는 타입

 대상

어졸려 죽겟다
ㅠㅠㅠㅠ

is 연산자는 잘쓰지는 않는뎅...
노니 연산자는 어떻느징라아트루 연산자는 요거 전체 표현식으로 실행하ㅕㄴ 값으로 나돈디ㅏ,허ㅏ앞에나온댈 일 잘 시킬것 같아
?
뭐라는거야


논리연산자는 주로 여러조건을 합칠때 if 문에서 많이 사용을 함

조건 둘다 많이 만조하나라도 

단축평가
트루 폴스가 아님

판단을 할때 암시적으로 ㅅ단지 판단을 위해서 함시적으로 살짝 바꿔서 판단을 함
ㅡㄱ래서 요 단축평가ㅡ요렇게 가림
 아 쒸 지짜 졸려주게''''''''''''ㄱ

 그러면 이 문자 전체 결과를 유추할수 있을까?

 단축 평가 같은 경우에는 가장 판별하기 위해서 가장 마지막에 본 요소를 반화능ㄹ 한다 마지막에 나타난 요소가 값으로 확정된다.
 판별하기 위해 가장 마지막에 확인한 요소가 값으로 확정이 된다 그것이 단축평가
저내채판단 못하고 뒤 ㅛㅇ소 화
?
뭐라는거야

와 진짜 개 졸리다
너무 졸려서 지금 계속 졸리다
와 큰일났다 머리에 하나도 안남는다
살려줘
살려줘!

단축평가 쓰면 코드 실행 자체를 최소화를 해줌

합치는 것도 종종 사용
연산자 우선순위도 잘 정리

결과적으로 정리할 것
단축평가
형변환
그다음에 데이터 타입 당연하게 정리해야함

