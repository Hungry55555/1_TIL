월말 펴가는 함수 위주로 나오니 잘 정리하고
재귀함수는 피할수 없음

유용한 함수 map하고 찍 나옴

함수를 무조건 잘 알아야함
어떻게!!!!!
정의를 하고 리턴값을 반드시!!!있어야한다 리턴값이 없으면 어떻게 동작한다 이렇게 알아야함

어제 했던거
중요한 내용 위주로만 정리

함수는 안쓰면 유지보수 힘들고 가독성이 떨어짐 안썼을때의 단점이 너무많아서 함수는 그냥 기본처럼 사용할 수 있어야함

알고리즘을 풀때도 안쓰고 풀어도 되지만...

내장함수
월말평가 몇개가 사용불가능해짐

min, max, sum, len 같은거 못쓸수 있으니 반복문 이용해 구현하는거 생각하셈
알고리즘 들어가면 봉인
IM이후 봉인해제됨
ㅋ

함수 호출과 정의가 다른 개념이다

함수 반환값 필요한 경우 반환 가능
리턴 키워드 이후에 반환할 값을 명시
리턴 만나면 함수 종료됨
ㄴㅇㄱ
뒤에 코드 있어도 못본척함

어떤 함수를 받아서 실행하니
프린트를 하니 none이다 펑크의 리턴이 없는 상태구나~!
프린트는 리턴이 none 인 함수

def가 없다면 호출!

매가변수는 값이 저장되기 위한 값
직접 넣은 값은 인자
호출에서 들어가는 저장되어지는 값 인자임

함수 전달에는 기본인자값 정의 할때 매개변수의 값을 할당해 두는 것

위치인자와 기본인자 반드시 당연하게 알아야 하는거라 정리해놔야함


해당 매개변수에 바로 값이 저장되는거라 위치가 바뀌어도 상관없는것이 바로 키워드인자

위치 인자 키워드 인자
키워드 인자는 위치인자 뒤에 위치해야함


정의하지 않은것을 처리할때 사용하는것이 가변인자리스트

### 정의할때 매개변수 앞에 *이 붙으면 이게 가변인자 리스트가 된다.
이름에 리스트가 들어가지만 실제로는 tuple로 처리가 되고 여러개의 값을 tupe로 묶어서 처리를 한다

함수를 정의할때

### 가변 키워드 인자 리스트
함수 정의시 매개변수 앞에 **이 들어간것이고 여러 인자를 dictionary로 묶어처리하는것으로
매개변수=값형태가 매개변수:값으로 들어감
dict로
이것도 함수 정의할때 들어감!
인자의 종류는 크게 4가지가 있음

위치 인자는 해당 위치에 있는 매개 변수로 매칭되어서 저장되는 그런 형태
위치 인자

기본값인자

함수를 정의할때 매개변수가 들어오지 않는다면 기본값을 할당해서 사용할수 있도록 만드는것
기본값이 할당되는 형태로 되는 형태다

키워드 인자 

얘는 호출할때 어떤 상황이냐에 따라서 똑같이 생겼지만 다르게 전달을 한다

임의의 인자

매개변수 앞에 *를 붙여 여러개 인자를 tuple로 묶어 처리하는데 튜플은 리스트처럼 동작하는데 불변이라는 특징이 있어서
파이썬으로 동작할때 묶는것은 대부분 튜플을 사용하여 동작함

가변 키워드 인자 리스트
함수를 정의할때 들어오는 키워드 인자를 딕셔너리로 묶어서 처리를 함
그래서 총 5개의 인자 종류가 있음

가변 인자 리스트


정의
기본 가변 키워드

호출
위치 키워드

함수 인자 권장 작성순서

위치 기본 가변 가변 키워드

정의 때 저렇게 정의하는걸 추천~

### Scope
함수를 기준으로 로컬과 글로벌이 구분되어짐

글로벌은 함수 바깥에 있는 공간

로컬은 함수 내에 있는 공간

로컬은 함수 내부에서만 참조 가능하고 외부에서는 참조가 불가능함

글로벌에 정의된 변수

로컬에 정의된 변수

scope 예시
num은 로컬 스코프에 존재하기 때문에 global에서 사용할 수 없음


변수 수명 주기

빌트인:파이썬 실행되는한 영원히
글로벌: 파이썬 실행이 끝날때까지
로컬: 함수가 호출될때마다 호출되고 끝나면 사라져서 함수가 종료될때까지 유지가 된다.

빌트인 글로벌 로컬 총 3개

이름 검색 규칙

이름 식별자 = 변수
가장 좁은 범위 부터 넓은 범위로 감

가장 먼저 로컬에서 해당 변수가 있나 찾아보고 인클로즈드는 일단 없다고...
그다음 글로벌에서 찾음
그다음이 빌트인 스코프를 찾아봄

그리고 함수 내에서는 바깥에 있는 변수에 접근이 가능함
리드 온리는 가능하지만 수정은 할 수 없음
수정하려면 로컬에서 글로벌 수정하려면 글로벌이라는 키워드를 붙여주며 선언해줘야함

값이 저장된 메모리에 가서 값을 읽어올수있음

함수 내부에서 넘 자체가 global이다라고 알려줘야함

하지만 num_list = [1,2,3,4] 이건

로컬에 가져와 써도 에러가 생기지 않음

이건 데이터 타입 특징대문

리스트 같은 경우에는 리스트 값이 들어간게 아니라 리스트 자체가 값의 모임
값의 모임은 값이늘어났따 줄어들었다 하기 때문에 넘 리스트는 해당 리스트의 시작 주소를 가르킴

넘 리스트를 하면 에러
하지만 넘 리스트 내부에 있는 걸 바꾸면 가능~
리스트의 시작 주소 위치는 바뀌지 않고 내부 값이 바뀌는건 넘리스트와는 관계없어서 그냥 그렇게 되었다

넘 리스트 얼레벌레 컬렉션 타입들은 따로 글로벌을 사용하지 않아도 되더라

LEGB 좀 망각했을때 집에가서 아까 500 어쩌구 해보도록

값을 단지 참고할때는 굳이 글로벌 안써도 괜찮지만 굳이 내부에서 수정하려면 글로벌을 사용해야함

이건 그냥 한 번 읽어보시길..
신택스 에러가 발생

글로벌 키워드는 진짜 쓰지 마라 여기서나 쓰는거지 진짜 고용ㄷ사용되고 변하지 않는 상수값이나 써라
글로벌값을 수정하고 싶으면 함수 인자로 받아 처리하고 그 반환값을 처리한다

## 재귀 함수
함수 내에서 자기자신을 호출하는 함수
특정 알고리즘 식을 표현할 때 코드ㅢ 가독성이 높아짐

1개 이상의 베이스 케이스 종료되는 상황으로 존재하고 재귀가 발산이 아니라 수렴하는 형태로 작성해줘야 함

1일때 1을 반환하게 하고 나머지느 전부 작아지게 반환을 하는 쭉쭉쭉쭉
점화식

유용한 함수 map과 zip

전치행렬 만들때 나중에 스임

맵은 순환가능한 객체들의 요소를 이 함수에 다가 전달하는 그런 실행하는 거!
map object...
이상하게 나옴....
미친놈인게 확실함

실행을 바로하는게 아니라 현재 준비된 상태
값이 필요하다고 하면 준비된 코드가 하나씩 값을 넣어서 그 결과를 돌려줌

모든지 실행된게 아니라실행 준비된 상태로 값이 필요할때 실행이 된다.

for i in map
list로 형 변환을 하게 되면 모든 값을 필요로 하기 때문에 형변환이 되면서 값이 튀어나오게 된다.

오브젝트 어쩌구가 나온다 준비된 상태다
내가 달라고 할때마다 값을 하나씩 주겠구만!
zip은 iterable
그렇게 들어오면?
같은 인덱스 끼리 튜플로 묶어줌
집도 보면 오브젝트임

살려줘!!!!!!!

람다함수는 나중에 자바할때쯤이면 람다를 마스터한다
ㅎ...
사람살려...

함수명이 없어서 익명함수라고 부름

람다 키워드 호출하고 매개변수: 표현식은 리턴되는 값
반환되는 값을 표현식으로 작성해라!

리턴 생략

패킹 여러 값을 변수 하나로 묶어담는것을 패ㅏ킹 이라고함

패킹은 여러개를 튜플 형태로 묶음

ㅎㅎㅎㅎㅎㅎㅎㅎㅎ
변수 값 할당할때 *를 찍으면 포장 패킹이다

함수를 정의할때 가변인자 리스트 이건 함수정의할때니까 매개 변수
변수 앞에 붙여주면 값을 할당하기 위한 변수에다가 별을 붙여주면 패킹이됨

가변인자리스트도 따지고 보면 패킹임

매개변수에 별을 붙이는 것

풀어 버리는것
언팩킹

일단
요고는 기본적ㅇ으로 변수를 얘는 패킹

언패킹
요 값을 요렇게 사용할 수 있음

근데 이렇게 쓰기 보다는
함수를 호출할대 인자앞에 *이 붙으면 
인자는 전달되는 값
전달되는 값앞에 *이 붙으면 이거는 언팩킹이 된다.

앞에 있는 요 대괄호가 없어지는 효과가~

패킹은 함수를 정의할때 매개 변수앞에 *이 붙은것

비닐 포장 준비

함수를 호출할때 전달되는 값 앞에 *을 붙이면 비닐포장을 벗기는 것

키 값이랑 매개변수랑 일치해야지만 사용이 가능함
키워드 인자 형태로 비닐이 풀림
키워드 인자라 함은 key=value 형태로 전달이 되어 지는데 요 값이 존재해야 한다.
그러면 쏙 들어감

하다보면 익숙해질듯 지금은 답 이 약간 안보임

정리하자면 패킹 연산자로 사용할때는 하나의 튜플로 묶고 언패킹 연산자로 사용할때는 함수의 인자로 전달할때

** 언패킹연사자로 사용할때는 키값ㅆ아을 키워드 인자로
언패킹하여 함수의 인자로 전달하는 역할

인자(전달되는 값)
앞에 *이나 ** 언패킹


---

어제꺼
시퀀스는 수넛대로 나열해서 정리하는 타입
시퀀스 특징 기억하기

리스트 넘어감~
알고리즘에서 리스트 모르면 큰일나니까 기본으로 이해하고
튜플은 리스트와 같은데 변경이 불가능하다는 차이가 있음

튜플에서 주의할때 정의할때 반드시 뒤에 ,를 적어줘야 튜플로 인식하게된다

튜플은 리스트와 거의 비슷함

레인지는 특정 연속된 정수 시퀀스를 생성하는 변경 불가능한 자료형

레인지 앞에 들어가는건 이상 미만
하나 있을때는 0부터 시작

넌 시퀀스 타입으로는 딕셔너리와 셋이 있음
단어가 키
뜻이 밸류라고 불린다라고 생각하면 키밸류 쌍에 대한 이해는 끝났다
사전 단어와 뜻 쌍 같이
딕셔너리
표현은 중괄호
ㅆㅇ을 그대로 안에다가 넣어주면 됨~
키를 입력을 해주면 값에 접근 가능
set 중복이 없는 변경 가능 자료형 
리스트에서 중복 제거위해 셋으로 형변환 했다가 리스트로 형변환 시킴
그러면 중복제거가 간ㅇ함

셋같은 경우는 순서가 없음
셋은 순서가 없어 셋은 저ㅓㅂ근때 훨씬 빠ㅡ게 다닐수 있는데 셋 연산자를 할대 리스트 보다 인을 사용할때 속도가 좀 더 빨림
인 연산잘르 쓸때는 셋으로 형변환 해서 사용해도 무방함

집합 연산자로 많이 사용하는 합집합 차집합 교집합 셋 타입으로 전부다 계산이 된다.
다른 타입

넌

값이 없음을 표현하는 자료형

불린 참 거짓 나타내는 자료형

컬렉션 여러개의 항목을 담는 자료 구조

그래서 컬렉션 정리하면 다음고 ㅏ같음

스트링 튜플 변경 불가하고 순서는 스트링 리스트 채플은 존재한다

저 테이블 잘 정리해 두게나

파이썬 튜터로도 한 번 눈으로 식ㄱ화해서 두어라!!
암시장의 형 변화는
숫자형에서 서로 데이터 타입을 암시적으로 형변환이 일어나고 데이터손실을 최소화 할려고
손실!
그러면 안된까 조금도 많은것을 표혀핳ㄹ수있는 플롯으로 형변환이 된다'
트루 폴스 뿐
좀더 많은 것을 표현 할 수 있음
트루가 1호 불리언이 인트의 ㅓ브클래스
암시적 형변환
 uf 듀ㅏ애 ㅈㅎ곤'
 이 조건을 판별할ㄸ이 조건이 숫자로 무시함 이때 참읹 ㅓ지신지 확인을 해야함
 비어있는 딕셔너리 요런 값들은 전부다 펄스를 의미하고 값이 존재하기만 하면 전부다 트루가 된다
 그럼 if 'false:
 문자열이 존재하기 때문에 true로써 판단이 됨
 이때 암시적으로 변환을 해서 판단을 한다
 숫자 3.5를 인티저로 한방에 변화가 안된다
 컬렉션 간의 형 변환 정리
ㅂ     변환하려는 타입

 대상

어졸려 죽겟다
ㅠㅠㅠㅠ

is 연산자는 잘쓰지는 않는뎅...
노니 연산자는 어떻느징라아트루 연산자는 요거 전체 표현식으로 실행하ㅕㄴ 값으로 나돈디ㅏ,허ㅏ앞에나온댈 일 잘 시킬것 같아
?
뭐라는거야


논리연산자는 주로 여러조건을 합칠때 if 문에서 많이 사용을 함

조건 둘다 많이 만조하나라도 

단축평가
트루 폴스가 아님

판단을 할때 암시적으로 ㅅ단지 판단을 위해서 함시적으로 살짝 바꿔서 판단을 함
ㅡㄱ래서 요 단축평가ㅡ요렇게 가림
 아 쒸 지짜 졸려주게''''''''''''ㄱ

 그러면 이 문자 전체 결과를 유추할수 있을까?

 단축 평가 같은 경우에는 가장 판별하기 위해서 가장 마지막에 본 요소를 반화능ㄹ 한다 마지막에 나타난 요소가 값으로 확정된다.
 판별하기 위해 가장 마지막에 확인한 요소가 값으로 확정이 된다 그것이 단축평가
저내채판단 못하고 뒤 ㅛㅇ소 화
?
뭐라는거야

와 진짜 개 졸리다
너무 졸려서 지금 계속 졸리다
와 큰일났다 머리에 하나도 안남는다
살려줘
살려줘!

단축평가 쓰면 코드 실행 자체를 최소화를 해줌

합치는 것도 종종 사용
연산자 우선순위도 잘 정리

결과적으로 정리할 것
단축평가
형변환
그다음에 데이터 타입 당연하게 정리해야함

