## 함수 (Functions)
* 특정 작업을 재사용할수있는 코드 블럭

## 내장 함수 (Built-in function)
* 파이썬이 기본적으로 제공하는 함수 (별도의 import 없이 바로 사용 가능)

* 주의 사항: 오래된 책에서 외장함수라고 반대 단어를 쓰는데 이건 원문에 찾아볼수 없고 과거 번역에서 내장의 반대로 만든 단어같은데 공식적으로 영어로도존재하지 않음

내장함수 예시
* abs (절댓값을 반환하는 함수)

함수는 사용한다가 아니라 호출한다고 한다 function call
function_name(arguments)
함수 호출에서는 반드시 소괄호를 열고 닫아야함
함수를 실행하기 위해 함수 이름 사용하는 것

## 함수의 구조
두 수를 입력 받는 곳이 input()
그 밑이 결과

parameter: 여기서 들어가는 값, 매개 변수라고 부름
빨갛게 들여쓰기 되엉있는 부분: 함수의 바디, 이 함수의 바디 안에서 주석 처리가 여러줄
여러줄 주석 함수에서 Docstring 이라는 걸 사용하는데
여기는 보통 이 함수를 사용하는 가이드를 작성

return value: 반환값 무언가 최종적으로 만든 결과
return 키워드와 함께 사용을하고 함수는 리턴과 함께 작업이 종료됨

함수 정의 (정의): 함수를 만드는 과정을 정의한다고 함 define
그래서 함수 만들 때 키워드가 def
* 함수 정의는 def 키워드로 시작
* def 키워드 이후 함수 이름 작성
* 괄호안에 매개변수를 정의할 수 있음
    * input으로 들어오는 전달되는 값
* 매개변수(parameter)는 함수에 전달되는 값을 나타냄

### 함수 body
함수를 작성하고 ()까지 썼으면 :콜론 다음에 들여쓰기 된 코드 블록
함수가 실행 될때 메인 코드가 작성
Docstring은 함수 body 앞 최상단 작성 없어도 기능의 차이는 없음
바디에서도 함수는 결과를 반환
return 문은 함수의 실행을 종료하고, 결과를 호출 부분으로 반환

함수가 return이 반드시 있어야 하는 것은 아님
return을 만나면 그 함수는 끝남
즉 리턴 이후에 코드를 아무리 더 작성해도 리턴 아래 코드들은 실행되지 않는 죽은 코드가 됨
함수의 종료 조건

함수 호출
함수를 호출하기 위해서는 함수의 이름과 필요한 인자(argument)를 전달해야함
호출 부분에서 전달된 인자는 함수 정의 시 작성한 매개변수에 대입됨
매개 변수는 정의할때 매개변수라고 하고 인자는 호출할때 인자라고 부르고 있음 둘다 위치는 동일한 위치지만 상황에 따라 부르는 명칭이 다름

* 매개변수와 인자
매개변수(parameter)
함수를 **정의할 때**, 함수가 받을 값을 나타내는 변수
인수(argument) 함수를 **호출할때** 실제로 전달되는 값

책에서는 둘 중 하나로 만 언급하는 경우가 있는데 명확하게 말하면 둘은 다름

여기 a와 b는 add number로 전달된 인자 들

## 인자의 종류 (소주제로 되어있지만 굉장히 중요한 것)
인자를 좀 더 다양한 방식으로 받을 수 있는 능력이 있어야함
반드시 두 개의 인자를 받을 수 있음

근데 2개로 제한 더 강력한 함수 만들고 싶음!

* 위치 인자: 함수 호출 시 인자의 위치에 따라 전달되는 인자 앞서 본 함수들 예시가 전부 위치인자
    * 위치인자는 함수 호출 시 반드시 그 값을 가지고 있어야함

위치 인자 이름이 위치! 인자라서 위치가 제일 중요함

기본 인자 값
함수 정의에엇 매개 변수에 기본값을 하랑하는 것
함수 호출 시 인자를 전달하지 않으면, 기본값이 매개변수에 할당됨
age = 30 기본인자 값
알아서 기본값은 우선순위가 밀림
그래서 값을 넣으면 알아서 값이 온전히 잘 활용이됨
이게 바로 기본 인자 값
이게 바로 두 번째 케이스

* 키워드 인자
호출 할 때 전달하는  방식
기본인자 값은 정의할때 기본값을 세팅
호출할때 쓰는것
함수 호출시 매개변수 이름을 써서 넣어줌
어렵넹
지정해서 넣어줌 위치를 일치시키지않았지만 특정 매개변수 이름만 명확하게 알고 있다면 전달을 할 숫 있음
이게 바로 키워드 인자 사용방식

** 주의 사항
위치인자는 등장할 수 없다 키워드 알규먼트 후에는 위치인자가 등장할 수 없다
실행 해봤자 위랑 똑같음
키워드 인자 다음에 위치 인자 자체가 ㄷㄹ어올 수가 없ㅇ므
근데 파이썬 입장에서 보면 이 두번째가 위치인자로 받아들여야하는데 위치인자가
위치인자가 네임이라는 것을 자도으로 알 수 있나? 파이썬이 알아들을 수 업승ㅁ

어디 위치인자??
문법 구조상 애초에 활용이 안된다.
다행인점은?
어차피 잘못쓰면 실행이 안된다

키워드 인자 사용 주의 사항
* 호출 키워드 인자는 위치 인자 뒤에 위치해야함
쪼금만 생각을 해보면 파이썬이 알아들을수없겠구나 싶음

임의의 인자 목록
* 여기서는 이제 함수가 점점 각력해짐
정해지지 않은 개수의 인자를 처리하고 싶음
한개를 받건 두개를 받건 다 유연하게 처리해야함
프린트 함수를 쓰면서 프리느 함수는 내가 어떻게 몇개를 받을지 아는거지
프린트는 함수슬 쓸때 임의의 인자 몇개를 받는 것
함수중 *리스크를 붙이ㅕㅁ 여러개 임의의 갯수를 취ㅡㅂ하겟다

0개 이상
결국 얘가 다중으로 처리가 묶여야함
ㅁ=

여러개 데이터를 묶는 데이터 타입들

args 출력해봤는데 튜플임
튜플 특징
일단 시퀀스 변경 불가능 파이썬의 내부 동장에서 자동으로 많이 사용된다 변수가 할당되거나 자동할당하거나
임의의 인자로 받ㅇ[ㄷ로어쟀ㄷㄴ 묶어야한다는 의미가 됨 그래서 얘가 선택한 방식이 tuple로 묶어서 받아옴
그래서 여기서 1,2,3 튜플 3개 가 아니라 하나의 튜플이 나오는 것
그 썸을 내장함수에 넣은 것
이게 바로 함수에서 정해지징ㅏㄶ은 갯수의 인자를 처리하는 방법
츄흘로 만들어져서 썸이라는 함수의 인자로 들어가게 됨
]

인자 종류
마지막
임의의 키워드 인자 목록
이건 키워드 인자 목록저런식으로 인자를 여러 개 넣는 것
매개 변쉥 ㅓㅈ
한 묶음 이건 어떻게 묶을까값을 값으로 씀
네임이 키가 됐고 이브가 값이 됨 에이지가 키가 되고 30이 값이됨
둘다 정해지지 않는 개수라는 고통점이 있음
디ㄱ셔너리로 묶는건 아까와 다르게 함수정의 앞에 **를 붙임

난리남
그래서 함수 권장순서
위치->기본->가변->가변 키워드
위치인자는 반드시 높은 우선순위를 가져서 앞쪽에 놔야함
그이후는 함수의 상황에 따라 다르긴함


# 함수와 scope
* scipe는 공간 영역 범위
## Python의 범위 (Scope)
함수는 로컿과 글로벌로 공간이 나뉨
스코프
    * 글로벌 스코프: 코드 어디에서든 그 해당하는 값을 확인할 수 있는 영역
    * 로컬은 이제 거기 울타리가 쳐짐 모두가 있는 전역 중간중간에 울타리가 쳐짐 근데 그 울타리 기준은 함수
    이 함수의 바디 안쪽은 로컬 영역
    전역에 있는 공간과 전혀 다른 공간이다
     전역은 내가 어디잇는 값을 참조하고 할 수있었음
     전역 변수와 지역변수 변수가 어디서 만들어 지느냐에 따라서 이 변수는 전역에 있는거고 이변수는 로컬에 있는거고
     그 울타리 기준은 함수

    함수를 기준으로 영역이 나뉘어 짐
    
    아래 예시를 보니 펑션이라는ㄴ 함수가 만들어짐
    ㅎ마수 호출했을때 결과가 local 20근데 여기서 넘을 했더니 에러가 뜸
    넘이라는 애가 정의되지 않았다
    왜 이건 넘을 출력하지 못햇을까?
    바로 영역이 다른 영역에 있기 때문
    스코프 기준이 함수
     이 영역 따ㅗㄹ 별도 인것
     넘이라는 변수는 존재하지않음
     이는 변수의 수명 주기와 관련있음 변수가 태어나고 죽은 이런 일련의 시간이 있음
     이 변수가 얹 죽냐에 따라 이 게 나뉨

빌트인 스토프라는 영역이 존재
빌트인은 그냥 파이썬이 끝날때까지 살아있고 아무데서나 활용가능
함수나 이런게 호출된 이후 이 파이썬 번역기가 끝날때까지 유지
글로벌 스코프는 이제 로컬에 있는건 참조가 안된다

밖에서는 왜 못쓰는가

수명은 함수가 종료될때 죽음
그래서 울타리가 함수 기준
왜냐면 함수와 함께 생성되기 때문 넘이라는 변수는 함수의 호출때 탄생 종료때 사망

이 넘이라는 변수는 호출에 태어나서 호출이 끝나서 죽음
파이썬에서는 이 변수들의 수명 주기로 영역을 나누고 있음

변수를 ㄹ찾아나갈수 있음 1번에서 4번 밖으로는 찾아나갈수 있지만 반대방향은 안됨!

작은영역에서 없으면 밖으로 찾지만 밖에서 안으로는 들어갈 수 없음
LEGB룰 규칙
내장함수 sum
변수명 지을때 이미 정해져 잇는 키워드는 쓰지 않기로햇는데 변수를 함수 이름으로 만들어버림
이러면 글로벌영역에 변수 썸이 생겨버림...
근데 이제 빌트인에 있는 함수에 썸이 존재함
근데 내가 썸이라는 내장함수로 쓰려고 하면 에러가 뜸
정수 객체는 호출할수없음
썸이 지금 정수로 인식되고 있기 때문

빌트인으로 찾아올라가기 전에 이미 존재했기 때문

내장된 걸로 변수명을 지으면 안되는건 LEGB룰이랑 연관이 되어있기 때문

이럴경우는 당연히 변수 이름을 다른걸 로 바꿔야함

함수는 호출이 중요함 함수의 호출되는 시점을 잘 봐줘야함

로컬 ㅕㅇ역에서 global 키워드를 앞에 붙이면 전역 변수로 선언가능

알고리즘 할때 공통되는 조작해야할경우 활용을 함 하지만 일반적 코딩 상황에서는 권장하지 않음

그럼 저 전역변수 쓰는 다른것 도 영향ㅇ을 줘서 권장 안함

글로벌을 반드시 쓸 수 있는 건 아니고 글로벌 선언전에 미리 접근할 수 없음

매개 변수에 있는 이름 을 같은 이름의 글로벌로 활용할 수 없어서 매개변수 이름을 바꾸던지 해야함


글로벌 키둬드는 가급적 사용하지 말고
자꾸 글로벌 꺼를 컨트롤 하지 말고 값을 받아서 사용을 해라


* 재귀 함수
재귀함수 재귀적
자기 자신을 계속해서 반복을 하는것
함수 내부에서 자기 자신을 또 호출하는 것

하지만 무한정 호출하면 곤란하니 특정 알고리즘 공식을 쓸때 재귀함수를 쓰면 가독성이 높아짐
알고리즘을 배우면 알고리즘 공식을 재귀함수를 쓰면 직관적으로 보이는 경우가 있음

반드시 한개 이상의 종료 되는 상황이 존재하고 수렴하도록 작성

큰 문제가 있으면 계속 작은 단위로 쪼개 가면서 문제를 풀때 많이 사용
재귀함수를 쓰는건 팩토리얼 예시로 많이 사용됨

어휴...점점 어려워진다...이 산이...아닌가 보오...

큰 문제를 작은단위로 풀어갈때 사용을 함

본격 사용은 나중에...

이해가 안가는디...
당연함

알고리즘으로 팩토리얼 다시 등장

재귀함수는 종료조건을 명확히 해야함
아니면 무한 루프에 빠짐 점점 종료 조건으로 방향을 향해감

유용한 내장 함수

map 과 zip 함수
map(function, iterable)
첫인자로 함수르 받고 두번째 인자로 반복가능한 친구를 받음
반복을 돌릴수있는 친구들 대표적으로 시퀀스인 친구들
문자열
튜플
리스트
레인지
이런친구들

반복을 하면서 이 특정한 함수를 요소요소마다 적용할 숭 ㅣㅇㅆ음

맵 함수로 만든 결과는 맵덩어리 맵객체 라 이걸 내가 쓰고싶은 타입으로 변환해주면 저러헥 최종본으로 보임

그 과정에서 map이 쓰임

한줄로 쓸 수 있는 건 풀어서도 쓸 수 있어야함

zip(*iterables)
두개의 리스트를 쌍을 지어서 묶어줄때 유용하게 쓰임

집함수 매개변수에 *가변인자

람다 함수
    * 익명 함수
함수에 지금가지 전부 이름이 있었지만 이녀석은 이름이 없음
일단 def가 없고 람다라는 키워드가 있고
매개변수: 바디 등장

람다는 한줄짜리
변수에 이렇게 호출하게 됨

한줄짜리로 단일 일회성 함수를 쓸때 많이 사용함

바로 맵이랑 굉장히 많이 쓰임
맵에서 첫번째 인자 들어갈때 여기 함수가 들어간다는데 여기서 많이 쓰임

패킹 언패킹
싸고 풀고
패킹
여러개의 값을 하나의 변수에 묶어서 담는 것
* 가변인자 여러 개의 인자를 묶는것 이걸 변수의 할당에서도 쓰임 얘네를 하나의 튜플로 묶여서 활용
이게 패킹

키워드 인자는 뭐라고?
돌아버리겠네

기본인자는 바꿀수 있음
오....
개빡치는데....
공식문서에서 내장함수를 보고 응용 가능

언패킹
패킹의 반대로 묶여있던걸 분할해서 푸는 것
